<?php
namespace RightNow\Libraries;
use RightNow\Utils\Text,
    RightNow\Utils\Config,
    RightNow\Api;

/**
 * Determines if requests constitute abuse and should be subject to a reCaptcha challenge.
 */
class AbuseDetection
{
    private static $memcacheAbuseKeysHandle = null;
    private static $hasSentChallengeValidation = false;

    /**
     * Stores the result of isAbuseCore so that we don't hit Memcache twice if somebody calls isAbuse() or check() twice.
     */
    private static $isAbuse = null;
    private static $hasSentUsageToAbuseRelay = false;

    /**
     * Determines if the current request appears to be abuse. If it's not, unlocks the abusable APIs.
     * @param string $formToken A string generated by createTokenWithExpiration which can indicate that the request must be accompanied by a valid challenge response.
     * @return boolean Denoting if the current request is abusive.
     */
    public static function isAbuse($formToken=null) {
        if (self::$isAbuse === null || IS_UNITTEST) {
            self::$isAbuse = self::isAbuseCore($formToken);
            if (!self::$isAbuse) {
                \RightNow\Connect\v1_3\CustomerPortal::unlockAbusableMethods();
            }
        }
        return self::$isAbuse;
    }

    /**
     * Determines if the current request appears to be abusive. If it is, outputs a challenge indicator and the script for a challenge
     * provider (see getChallengeProvider). If not, unlocks the abusable APIs.
     * @param string $formToken A string generated by createTokenWithExpiration which can indicate that the request must be accompanied by a valid challenge response.
     * @return void
     */
    public static function check($formToken=null) {
        if (self::isAbuse($formToken)) {
            $isRetry = self::getAbuseChallengeInputs();
            $response = ($isRetry) ? "==CHALLENGE INCORRECT==" : "==CHALLENGE REQUIRED==";
            $json = array(
                'challengeProvider' => self::getChallengeProvider(),
                'dialogCaption' => $isRetry ? Config::getMessage(RESPONSE_ACCEPTED_PLEASE_TRY_MSG) : Config::getMessage(CHALLENGE_REQUIRED_LBL),
            );
            \RightNow\Utils\Framework::writeContentWithLengthAndExit("$response\n" . json_encode((object) $json));
        }
    }

    /**
     * Returns a block of JavaScript which can display an abuse challenge, such as an image from recaptcha.net.
     * @return string Code necessary to display a catpcha challenge
     */
    public static function getChallengeProvider() {
        $languageCode = Text::getLanguageCode();
        $scriptUrl = "//www.google.com/recaptcha/api.js?onload=onApiLoadCallback&render=explicit&hl=" . $languageCode;
        // Hard code the reCaptcha v2 key to avoid the config (ADS_CHALLENGE_PUBLIC_KEY) service pack issue
        $captchaPublicKey = '6LcHf0wUAAAAAFxRHKequHkHUGyUWA5dy24ZaB5s';
        $providerScript = 'var defaultChallengeOptions = {
            scriptUrl: "' . Text::escapeStringForJavaScript($scriptUrl) . '",
            publicKey: "' . Text::escapeStringForJavaScript($captchaPublicKey) . '",
            lang: "' . $languageCode . '",
            custom_translations: {
                visual_challenge: "' . Text::escapeStringForJavaScript(Config::getMessage(GET_A_VISUAL_CHALLENGE_LBL)) . '",
                audio_challenge: "' . Text::escapeStringForJavaScript(Config::getMessage(GET_AN_AUDIO_CHALLENGE_LBL)) . '",
                refresh_btn: "' . Text::escapeStringForJavaScript(Config::getMessage(GET_A_NEW_CHALLENGE_LBL)) . '",
                instructions_visual: "' . Text::escapeStringForJavaScript(Config::getMessage(TYPE_THE_TWO_WORDS_LBL)) . '",
                instructions_audio: "' . Text::escapeStringForJavaScript(Config::getMessage(TYPE_WHAT_YOU_HEAR_LBL)) . '",
                help_btn: "' . Text::escapeStringForJavaScript(Config::getMessage(HELP_LBL)) . '",
                play_again: "' . Text::escapeStringForJavaScript(Config::getMessage(PLAY_SOUND_AGAIN_LBL)) . '",
                cant_hear_this: "' . Text::escapeStringForJavaScript(Config::getMessage(DOWNLOAD_SOUND_AS_MP3_CMD)) . '",
                incorrect_try_again: "' . Text::escapeStringForJavaScript(Config::getMessage(INCORRECT_TRY_AGAIN_MSG)) . '"
            },
            cant_see_image: "' . Text::escapeStringForJavaScript(Config::getMessage(CANT_IMAGE_AUDIO_OPTION_MSG)) .'"
        };' .  file_get_contents(HTMLROOT . \RightNow\Utils\Url::getCoreAssetPath('debug-js/RightNow.UI.AbuseDetection.Provider.js'));
        require_once CPCORE . 'Libraries/ThirdParty/JSMin.php';
        return ThirdParty\JSMin::minify($providerScript);
    }

    /**
     * An optimization; possibly premature. Intended only for use by the CP framework.
     * @return void
     * @internal
     */
    public static function sendSpeculativeRequests() {
        // Checking if memcache_value_deferred_get exists is a proxy for determining if we're really CP or we're only really
        // marketing automation, which is half-CP and a different set of available APIs.
        if (!IS_ADMIN && 'POST' === $_SERVER['REQUEST_METHOD'] && function_exists('\RightNow\Api::memcache_value_deferred_get')) {
            try {
                // I can't send usage to the abuse relay here or non-mutating POSTs, such as answer search, will count hits against the
                // IP address' limit.

                self::sendChallengeValidation();
                self::requestAbuseKeysFromMemcache();
            }
            catch (\Exception $ex) {
                // We don't have a way to report the error.
            }
        }
    }

    /**
     * Returns true if 'isInAbuse' cookie is set otherwise false.
     * @return boolean Whether the cookie is set or not
     */
    public static function isForceAbuseCookieSet() {
        return ($_COOKIE['isInAbuse'] && $_COOKIE['isInAbuse'] === 'true');
    }

    /**
     * Returns an array of POST data for the current challenge response.
     *
     * @return array|boolean Array of responses or false if no response was present
     */
    private static function getAbuseChallengeInputs()
    {
        return strlen($_POST['abuse_challenge_response']) ? array(
            $_POST['abuse_challenge_response'],
            $_POST['abuse_challenge_opaque'],
        ) : false;
    }

    /**
     * Returns data used to calculate whether the request is absusive. Components include the
     * current controller class/method, sites DB name, and users IP address.
     *
     * @return array List of abuse details
     */
    private static function abuseData() {
        static $abuseData;

        if (!isset($abuseData)) {
            $CI = get_instance();

            if (!CUSTOM_CONTROLLER_REQUEST && method_exists($CI, '_getAbuseResource'))
                $resource = $CI->_getAbuseResource();

            $abuseData = array(
                $resource ?: "{$CI->uri->router->fetch_class()}/{$CI->uri->router->fetch_method()}",
                Config::getConfig(DB_NAME),
                $_SERVER['REMOTE_ADDR'],
            );
        }
        return $abuseData;
    }

    /**
     * Determines if the provided form token specifies that a challenge should be shown
     *
     * @param string $formToken Encode form token
     * @return boolean Whether the current form token denotes a challenge is required.
     */
    private static function doesFormTokenRequireChallenge($formToken) {
        if (!$formToken) {
            $postFormToken = get_instance()->input->post('f_tok');
            if ($postFormToken) {
                $formToken = $postFormToken;
            }
        }
        return \RightNow\Utils\Framework::doesTokenRequireChallenge($formToken);
    }

    /**
     * Gets the abuse keys for the current site from memcache.
     * @return object A handle to the memcache keys.
     */
    private static function requestAbuseKeysFromMemcache() {
        if (null === self::$memcacheAbuseKeysHandle) {
            list($resource, $site, $ip) = self::abuseData();
            $siteAbuseKeys = array(
                "$site-$resource-$ip",
                "$site-$resource",
                "$site-$ip",
                "$site",
            );
            $podAbuseKeys = array("$ip");
            self::$memcacheAbuseKeysHandle = Api::memcache_value_deferred_get(MEMCACHE_TYPE_ADS, $siteAbuseKeys, $podAbuseKeys);
        }
        return self::$memcacheAbuseKeysHandle;
    }

    /**
     * Determines if the current request appears to be abusive.
     * @return boolean Whether the current request is abusive.
     */
    private static function isRequestAbusive() {
        try {
            $abuseValues = Api::memcache_value_fetch(MEMCACHE_TYPE_ADS, self::requestAbuseKeysFromMemcache());
            self::$memcacheAbuseKeysHandle = null;

            // if any of the values of these keys are more than 1, then abuse was detected
            foreach ($abuseValues as $value) {
                if ($value > 1) {
                    return true;
                }
            }
        }
        catch (\Exception $e) {
            // We've got nothing to do but report that there's no abuse.
        }

        //return true if isInAbuse cookie is set and is in development mode otherwise false
        return (self::isForceAbuseCookieSet() && (IS_DEVELOPMENT || IS_UNITTEST));
    }

    /**
     * Determines if the gearman check returned that the challenge response was valid.
     * @return boolean Whether the challenge response was valid.
     */
    private static function wasChallengeResponseValid() {
        $endTime = microtime(true) + 3.0;
        do {
            $isHuman = Api::gearman_validation_check_request();
            if ($isHuman == GEARMAN_CHECK_WAITING)
            {
                usleep(50 * 1000);
            }
            else
            {
                break;
            }
        } while (microtime(true) < $endTime);

        Api::gearman_validation_cleanup();

        // If any of these:
        // - recaptcha said it was valid (GEARMAN_CHECK_TRUE)
        // - we never heard back from the validator (GEARMAN_CHECK_WAITING)
        // - there was some kind of error (GEARMAN_CHECK_FAIL)
        // say true
        return ($isHuman != GEARMAN_CHECK_FAIL);
    }

    /**
     * Sends a gearman request to validate the challenge response.
     * @return void
     */
    private static function sendChallengeValidation() {
        if (self::$hasSentChallengeValidation) {
            return;
        }
        if (list($abuseChallengeResponse, $abuseChallengeOpaque) = self::getAbuseChallengeInputs()) {
            Api::gearman_validation_send_request($abuseChallengeOpaque, $abuseChallengeResponse);
            self::$hasSentChallengeValidation = true;
        }
    }

    /**
     * If a user fills in an abuse challenge correctly, then we give them a "coupon" for a free abusive hit later.
     *
     * The primary motiviation for this is the "ask a question" use case where:
     *   - The user would submit,
     *   - be prompted for a CAPTCHA,
     *   - fill it correctly,
     *   - get a FOGO (fill one, get one) coupon,
     *   - have the server respond with "smart" assistant response,
     *   - click the "yeah, yeah, I've already looked at those answers and they didn't help" button,
     *   - and then *not* be prompted for to fill another CAPTCHA because they've got a coupon.
     * @return void
     */
    private static function giveBonusHit() {
        $key = self::getBonusHitKey();
        if ($key) {
            try {
                // If we sent the request for the abuse keys but we haven't
                // actually fetched it yet, then fetch 'em now.
                // We need to do this because the libmemcached client won't
                // accept any other commands after a deferred get until the
                // matching fetch has been performed.
                if (self::$memcacheAbuseKeysHandle !== null) {
                    self::isRequestAbusive();
                }
            }
            catch (\Exception $ex) {
                // Don't care.
            }
            try {
                $setResult = Api::memcache_value_set(MEMCACHE_TYPE_ADS, $key, 1, 0);
            }
            catch (\Exception $ex) {
                // Well, that's not going to work.  Bummer that we can't report an error.
            }
        }
    }

    /**
     * Shared logic between doesUserHaveBonusHit and giveBonusHit
     * @return string|boolean Bonus hit key or false if not session ID exists for the user.
     */
    private static function getBonusHitKey() {
        $sessionID = get_instance()->session->getSessionData('sessionID');
        if ($sessionID) {
            return "bonusHit-$sessionID";
        }
        return false;
    }

    /**
     * We try to delete the record of the user's bonus hit.
     * If we succeed in deleting, it means that there was a bonus hit, which we're going to consume.
     * If deleting fails, there was no bonus hit.
     *
     * @return boolean True if they have a bonus hit.
     */
    private static function doesUserHaveBonusHit() {
        $key = self::getBonusHitKey();
        try {
            //memcache_value_delete returns null on success and throws on failure.  Didn't see that coming, did you?
            return $key && null === Api::memcache_value_delete(MEMCACHE_TYPE_ADS, $key);
        }
        catch (\Exception $ex) {
            // Usually this is because we tried to delete a non-existant key, but in
            // any event, we don't really care.  We're not going to report this
            // error and we don't have a way to log a failure.
            return false;
        }
    }

    /**
     * There are some requests that we want to exclude from consideration by the ADS because
     * there's really not a good way to handle them.
     * @return bool Whether request is exempt
     */
    private static function isRequestExemptFromAbuse() {
        return 0 !== preg_match('@^(/+ci/+pta|/+ci/+openlogin)($|/)@', ORIGINAL_REQUEST_URI);
    }

    /**
     * Determines if the current request appears to be abuse.
     * @param string $formToken Form token for the current form to check if request should always display a challenge.
     * @return bool Whether the site is in abuse. Returns false even if the site is in abuse, but the user has a bonus hit.
     */
    private static function isAbuseCore($formToken) {
        if (self::isRequestExemptFromAbuse()) {
            return false;
        }
        self::sendChallengeValidation();
        self::sendUsageToAbuseRelay();

        // If there's no indication that the request is abusive, then it's not abuse
        // without regard to the status of the challenge validation.
        $doesFormRequireChallenge = self::doesFormTokenRequireChallenge($formToken);
        if (!$doesFormRequireChallenge && !self::isRequestAbusive()) {
            return false;
        }

        if (self::$hasSentChallengeValidation && self::wasChallengeResponseValid()) {
            self::giveBonusHit();
            return false;
        }

        return !self::doesUserHaveBonusHit();
    }

    /**
     * Send abuse data to the abuse relay.
     * @return void
     */
    private static function sendUsageToAbuseRelay() {
        if (self::$hasSentUsageToAbuseRelay) {
            return;
        }
        self::$hasSentUsageToAbuseRelay = true;
        list($resource, $site, $ip) = self::abuseData();
        Api::ads_relay_submit($site, $resource, $ip);
    }
}